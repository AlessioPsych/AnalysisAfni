args <- commandArgs(T)
print( args )
mainDir <- getwd()
setwd( mainDir )

#rm(list=ls())
library( pracma )
library( abind )
library( neuRosim )
library( parallel )
library( circular )

inputDirection <- args[1]
sprintf('input direction:')
sprintf('%s', inputDirection )

# get TR
#instr <- sprintf('3dinfo -tr %s > __tttt.1D', inputEyeEPI); system( instr )
#trValue <- read.table('__tttt.1D'); system('rm __tttt.1D')
trValue <- 2

# get number of dynamics
#instr <- sprintf('3dinfo -nv %s > __tttt.1D', inputEyeEPI); system( instr )
#nDynamics <- read.table('__tttt.1D'); system('rm __tttt.1D')
nDynamics <- 162

#thetaCCW = linspace( 0, 2*pi, 11 )+pi/3;
#thetaCW = linspace( 0, 2*pi, 11 )+pi/3;
thetaCCW = linspace( 0, 2*pi, 11 );
thetaCW = linspace( 0, 2*pi, 11 );
thetaCW = thetaCW[ c( linspace( length(thetaCW), 1, length(thetaCW) ) ) ];

thetaExpCW <- ( as.numeric( repmat( thetaCW[1:length(thetaCW)-1], 1, 5) )  ) 
thetaExpCCW <- ( as.numeric( repmat( thetaCCW[1:length(thetaCCW)-1], 1, 5) ) )

if ( inputDirection=='cw' ) {
  thetaExp <- thetaExpCW 
}
if ( inputDirection=='ccw' ) {
  thetaExp <- thetaExpCCW
}

thetaExp <- circular( thetaExp, type='angles', units='radians', 
                      template='none', modulo='asis', zero=0, rotation='counter' )

# visualize stimuli sequence, remember that is polar angle coords, 'upper' is towards the right
visualizeStimFlag <- 0
if (visualizeStimFlag==1) {
  graphics.off()
  x11( width=7, height=4 )
  par(mfrow=c(1,3))
  for ( counterImg in 1:length(thetaExp) ) {
    polar( c( 0, thetaExp[counterImg] ), c(0, 1) , 'o', col='red', lwd=2  ); par(new=FALSE); Sys.sleep( 0.3 )
    plot( thetaExp[counterImg] )  
    cartCoords <- pol2cart( c( as.numeric( thetaExp[counterImg] ), 2 ) )
    plot( cartCoords[1], cartCoords[2], xlim=c(-3,3), ylim=c(-3,3) )
    abline(h=0,lwd=2,lty=2);abline(v=0,lwd=2,lty=2);
    Sys.sleep( 0.3 )
  }
}

#32 dynamics per full circle, build one circle then multiply it by 5
nSteps <- floor( 162*8 / 5 ) # one frame every 0.25 seconds, nSteps for 1 cycle = 259

width <- 28
x <- seq(-width/2,width/2,length.out = 200 )
y <- x
stimStore <- array( 0, c( length(x), length(y), 26, 10 ) )
mesh2dCoords <- meshgrid( x, y ) # build the mask

xLimScreen <- c(-4,4)
yLimScreen <- c(-5.5,5.5)

# generate the images
graphics.off()

for ( counterImage in 1:length( thetaExp[1:10] ) ) { # counterImage <- 1
  
  print( sprintf( 'Counter image: %d', counterImage ) )
  
  circleMask <- as.numeric( mesh2dCoords$X^2 + mesh2dCoords$Y^2 < 0.05 ) # mask
  
  stimStore[,,1,counterImage] <- as.numeric( circleMask ) #0.25
  stimStore[,,2,counterImage] <- as.numeric( circleMask ) #0.25
  image( x, y, stimStore[,,2,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  counterImgLoop <- counterImage
  cartCoords <- pol2cart( c( as.numeric( thetaExp[counterImgLoop] ), 3 ) )
  a <- dnorm( x, cartCoords[1], 0.05 )
  b <- dnorm( y, cartCoords[2], 0.05 )
  imgTarget <- a%*%t(b) # this is a 2d image generated by the matrix multiplication or crossproduct of two vectors (a,b, two gaussians), our pRF, a 2d gaussian
  imgTarget <- imgTarget > 0.001
  stimStore[,,3,counterImage] <- imgTarget + stimStore[,,1,counterImage] #0.25
  stimStore[,,4,counterImage] <- imgTarget + stimStore[,,1,counterImage] #0.25
  stimStore[,,5,counterImage] <- imgTarget + stimStore[,,1,counterImage] #0.25
  stimStore[,,6,counterImage] <- imgTarget + stimStore[,,1,counterImage] #0.25
  image( x, y, stimStore[,,6,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  for ( stepCounter in seq(7,19,2) ) { # stepCounter <- 7
    circleMask <- ( mesh2dCoords$X^2 + mesh2dCoords$Y^2 > 6 ) & ( mesh2dCoords$X^2 + mesh2dCoords$Y^2 < 15 ) # mask
    
    stimStore[,,stepCounter,counterImage] <- as.numeric( circleMask ) + stimStore[,,1,counterImage]
    image( x, y, stimStore[,,stepCounter,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
    
    stimStore[,,stepCounter+1,counterImage] <- stimStore[,,1,counterImage]
    image( x, y, stimStore[,,stepCounter+1,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  }
  
  stimStore[,,21,counterImage] <- stimStore[,,1,counterImage]
  stimStore[,,22,counterImage] <- stimStore[,,1,counterImage]
  stimStore[,,23,counterImage] <- stimStore[,,1,counterImage]
  stimStore[,,24,counterImage] <- stimStore[,,1,counterImage]
  stimStore[,,25,counterImage] <- stimStore[,,1,counterImage]
  stimStore[,,26,counterImage] <- stimStore[,,1,counterImage]
  image( x, y, stimStore[,,26,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )

  imgTempBlack <- stimStore[,,nImages,counterImage]
  image( x, y, imgTempBlack, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  for (nImages in 1:26) {
    print( sprintf( 'Counter image: %d; nImages: %d', counterImage, nImages ) )
    imgTemp <- stimStore[,,nImages,counterImage]
    imgTemp[ mesh2dCoords$X <= xLimScreen[1] | mesh2dCoords$X >= xLimScreen[2]  ] <- 1
    imgTemp[ mesh2dCoords$Y <= yLimScreen[1] | mesh2dCoords$Y >= yLimScreen[2]  ] <- 1
    stimStore[,,nImages,counterImage] <- imgTemp
  }
  image( x, y, stimStore[,,7,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  image( x, y, stimStore[,,22,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )

  imgTempWhite <- stimStore[,,1,counterImage]
  image( x, y, imgTempWhite, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  
  # shift input in the direction equal and opposite to the eye movement
  xArray <- array( mesh2dCoords$X )
  yArray <- array( mesh2dCoords$Y )
  oneArray <- rep( 1, length( xArray ) )
  xShift <- cartCoords[1]
  yShift <- cartCoords[2]
  matTransform <- matrix( c( 1, 0, yShift, 0, 1, xShift, 0, 0, 1 ), byrow=TRUE, ncol=3 )
  coordsTransformedMin_shift <- matTransform%*%rbind(xArray,yArray,oneArray)
  
  # select original, unshifted input, step = 22, after the masks
  img <- stimStore[,,22,counterImage]
  img02 <- interp2( y, x, img, coordsTransformedMin_shift[1,], coordsTransformedMin_shift[2,], method=c('nearest')  )
  img03 <- array( img02, dim( img ) )
  img03[ is.na(img03) ] <- 1
  image( x, y, img03, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  # select original, unshifted input, back background after the masks, 23
  img <- imgTempBlack
  img02 <- interp2( y, x, img, coordsTransformedMin_shift[1,], coordsTransformedMin_shift[2,], method=c('nearest')  )
  img04 <- array( img02, dim( img ) )
  img04[ is.na(img04) ] <- 0
  image( x, y, img04, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  
  # visualize original, unshifted input, step = 22, after the masks
  image( x, y, stimStore[,,22,counterImage], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')
  
  # visualize shifted input, step = 22, after the masks
  image( x, y, img03, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')

  # visualize shifted input, step = 23, after the masks
  image( x, y, img04, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')

  # visualize shifted input, step = 24, after the masks
  image( x, y, img04, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')
  
  # visualize original, unshifted input, step = 25, after the masks
  image( x, y, imgTempWhite, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')

  # visualize original, unshifted input, step = 26, after the masks
  image( x, y, imgTempBlack, zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  points( 0, 0, pch=1, cex=1.5, col='red')
  
  # shift step 23 and step 24
  stimStore[,,22,counterImage] <- img03
  stimStore[,,23,counterImage] <- img04
  stimStore[,,24,counterImage] <- img04
  stimStore[,,25,counterImage] <- imgTempWhite
  stimStore[,,26,counterImage] <- imgTempBlack
  
  # clean up border when not performing requested eye movements:
  for (nImages in c(1:21) ) {
    print( sprintf( 'Counter image: %d; nImages: %d, second correction', counterImage, nImages ) )
    imgTemp <- stimStore[,,nImages,counterImage]
    imgTemp[ mesh2dCoords$X <= xLimScreen[1] | mesh2dCoords$X >= xLimScreen[2]  ] <- 0
    imgTemp[ mesh2dCoords$Y <= yLimScreen[1] | mesh2dCoords$Y >= yLimScreen[2]  ] <- 0
    stimStore[,,nImages,counterImage] <- imgTemp
  }
  
  
}

graphics.off()

# total duration (26steps*0.25)*10directions*5cycles
26*0.25*5*10 # seconds, built sequence
162*2 #seconds, actual experiment
# need to correct for 1 second offset between the two. See below

counterImg <- 1
visualizeStimFlag <- 1
if (visualizeStimFlag==1) {
  graphics.off()
  x11( width=3, height=3 )
  for ( nImages in 1:26 ) { # counterImg <- 2
    print( sprintf('image: %d/26', nImages) )
    image( x, y, stimStore[,,nImages,counterImg], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) ); par(new=TRUE)
    Sys.sleep( 0.1 )
  }
}
graphics.off()

nImages <- 26
image( x, y, stimStore[,,nImages,counterImg], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) ); par(new=TRUE)


#concatenate all 10 different directions in a single 3D (2D+time) matrix
for ( k in 1:10 ) {
  if (k==1) {
    stimOut <- stimStore[,,,k]
  }
  if (k>1) {
    stimOut <- abind( stimOut, stimStore[,,,k], along = 3 )
  }
}
dim( stimOut ) 

# stimOut = all 26 steps, 10 direction, 1 cycle
# dim( stimOut )[3] * 5 5 cycles overall = 1300 steps overal per fMRI run, I am off by 4 steps, 0.25s * 4 = 1 second overshoot
visualizeStimFlag <- 1
if (visualizeStimFlag==1) {
  graphics.off()
  x11( width=3, height=3 )
  for ( i in 1:260 ) {
  image( x, y, stimOut[,,i], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
  par(new=TRUE)
  Sys.sleep(0.1) 
  }
}
graphics.off()

completeStimuliSequence <- abind( stimOut, stimOut, stimOut, stimOut, stimOut, along=3 );
dim( completeStimuliSequence ) 

# correct the one second overshoot (see comment above about overshoot)
completeStimuliSequence <- completeStimuliSequence[,,-c(25,260+25,260*2+25,260*3+25)]
dim( completeStimuliSequence ) 
dim( completeStimuliSequence )[3]*0.25/2 # 162 dynamics overall

save( completeStimuliSequence, file=sprintf('%s_completeStimuliKastnerOrig_borderOnlyAfterSaccade_shifted_final.Rdata', inputDirection ) )

# visualize
#x11(width = 2.5, height = 3)
#for ( i in 1:dim( completeStimuliSequence )[3]  ) {
#  image( x, y, completeStimuliSequence[,,i], zlim=c(0,1), las=1, col=gray( seq( 0,1,0.01 ) ) )
#  par(new=TRUE)
#  Sys.sleep(0.01) 
#}
#graphics.off()


